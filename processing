#!/usr/bin/env python3

import struct
import argparse
import os

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

SAVE_NETWORK			= 0x01
SAVE_TRAIN				= 0x02
SAVE_TEST				= 0x03
SAVE_NET_WEIGHTS		= 0x11
SAVE_NET_TARGETS		= 0x12
SAVE_TRAIN_DELTA_WMAGS	= 0x21
SAVE_TRAIN_ITER_COUNTS	= 0x22
SAVE_TRAIN_ENERGIES		= 0x23
SAVE_TRAIN_LENERGIES	= 0x24
SAVE_TRAIN_TRAINCOSTS	= 0x25
SAVE_TEST_LABELS		= 0x31
SAVE_TEST_PREDICTIONS	= 0x32
SAVE_TEST_OUTPUTS		= 0x33
SAVE_TEST_COSTS			= 0x34

class FileReader:
	def __init__(self, filename):
		self.dir, self.netname = filename.rsplit('/', 1)
		self.netname = self.netname.split('.')[0]

		self.f = open(filename, "rb")
	
	def get_name(self):
		return self.dir, self.netname
	
	def read(self, n, squeeze=True):
		data = struct.unpack(f'{n}Q', self.f.read(8*n))
		return data[0] if n == 1 and squeeze else data

	def read_mat(self):
		size = self.read(2)
		ret = np.fromfile(self.f, dtype='double', count=size[0]*size[1]).reshape(size)
		return ret[0] if size[0] == 1 else ret
	
	def _recursive_read(self, data, dims, depth):
		for i in range(dims[depth]):
			if depth == len(dims)-1:
				data.append(self.read_mat())
			else:
				data.append([])
				self._recursive_read(data[i], dims, depth+1)

	def read_data(self, format):
		start_pos = self.f.tell()
		self.f.seek(0, 2)
		end_pos = self.f.tell()
		self.f.seek(start_pos)

		while self.f.tell() != end_pos:
			try:
				type, ndims = self.read(2)
			except:
				return
			if type not in format.keys():
				continue

			dims = self.read(ndims, squeeze=False)

			format[type].append([])
			self._recursive_read(format[type][0], dims, 0)


	def close(self):
		self.f.close()



class TrainData:
	def __init__(self, filename):
		self.file = FileReader(filename)
		self.dir, self.netname = self.file.get_name()

		self.filetype, self.num_samples, self.nlayers, self.ntargets = self.file.read(4)
		self.targets = self.file.read(self.ntargets)

		self.delta_w_mags = []
		self.iter_counts = []
		self.energies = []
		self.lenergies = []
		self.train_costs = []
		read_dict = {
			SAVE_TRAIN_DELTA_WMAGS: self.delta_w_mags,
			SAVE_TRAIN_ITER_COUNTS: self.iter_counts,
			SAVE_TRAIN_TRAINCOSTS: self.train_costs,
			SAVE_TRAIN_ENERGIES: self.energies,
			SAVE_TRAIN_LENERGIES: self.lenergies
		}

		self.file.read_data(read_dict)
		self.file.close()

		self.delta_w_mags = self.delta_w_mags[0]
		self.iter_counts= self.iter_counts[0][0]
		self.train_costs = self.train_costs[0][0]
		self.energies= self.energies[0]
		self.lenergies = self.lenergies[0]

		self.colors = ['black', 'blue', 'red', 'green', 'yellow', 'orange', 'pink', 'brown', 'cyan', 'magenta']

	def _save(self, filename):
		plt.savefig(f'{self.dir}/train_{filename}.png')
		plt.close()
	
	def _title(self, title):
		plt.title(f"{title} - {self.netname}")


	def plot_dw(self):
		i = 0
		for layer in self.delta_w_mags:
			sns.regplot(x=np.arange(len(layer)), y=layer, label=f"layer {i}", scatter_kws={
				's': 10,
				'alpha': 0.2
			})
			i += 1

		plt.ylabel("Magnitude")
		plt.xlabel("Training sample")
		plt.yscale('log')
		plt.legend(loc="upper right")
		self._title("Magnitude of weight changes")
		self._save("delta_wmags")

	def plot_iters(self):
		sns.regplot(x=np.arange(len(self.iter_counts)), y=self.iter_counts, marker='x', scatter_kws={
			's': 10,
			'alpha': 0.2
		})

		plt.ylabel("Number of iterations")
		plt.xlabel("Training sample")
		self._title("Number of iterations")
		self._save("iters.png")
	
	def plot_train_costs(self):
		plt.plot(self.train_costs)

		plt.xlabel("Training sample")
		plt.ylabel("Cost")
		
		self._title("Cost during training")
		self._save("costs")

	def plot_energies(self):
		for sample in self.energies:
			filtered = [x for x in sample if x != 0]
			plt.semilogy(filtered)
		
		plt.ylabel("Energy")
		plt.xlabel("Iterations")

		self._title("Energy across iterations")
		self._save("energies")
	
	def plot_lenergies(self):
		count = 0
		for sample in self.lenergies:
			for layer in sample:
				filtered = [x for x in layer if x != 0]
				plt.semilogy(filtered, c=self.colors[count % (self.nlayers-1)])
				count += 1
		

		plt.legend([f"Layer {i}" for i in range(self.nlayers-1)])
		plt.ylabel("Energy")
		plt.xlabel("Iterations")

		self._title("Energy in each layer across iterations")
		self._save("lenergies")
	
	
	def plot_energy_residual(self):
		for sample in self.energies:
			filtered = [x for x in sample if x != 0]
			res = [sample[i] - sample[i+1] for i in range(len(filtered)-1)]
			filtered_res = [x for x in res if x != 0]

			plt.semilogy(filtered_res)
		
		plt.ylabel("delta energy")
		plt.xlabel("Iterations")

		self._title("delta energy across iterations")
		self._save("delta_energies")
	
	def plot_energy_ratio(self):
		for sample in self.lenergies:
			layers = np.array([np.array(x) for x in sample])
			# layer = np.array(sample[-1])
			total = layers.sum(axis=0)
			# print(f"flayer: {layers[-1]}, total: {total}")
			ratio = [layers[-1][i] / total[i] for i in range(len(total)) if total[i] != 0]

			plt.plot(ratio)
		
		plt.ylabel("Final energy / total energy")
		plt.xlabel("Iterations")

		self._title("Ratio of final energy to total energy")
		self._save("flenergy_ratio")

	def plot_all(self):
		self.plot_dw()
		self.plot_iters()
		self.plot_train_costs()

		self.plot_energies()
		self.plot_lenergies()
		self.plot_energy_residual()
		self.plot_energy_ratio()

class TestData:
	def __init__(self, filename):
		self.file = FileReader(filename)
		self.dir, self.netname = self.file.get_name()

		self.filetype, self.num_samples, self.ntargets = self.file.read(3)
		self.targets = self.file.read(self.ntargets)
		self.num_correct = self.file.read(1)

		self.labels = []
		self.predictions = []
		self.costs = []
		self.outputs = []

		format = {
			SAVE_TEST_LABELS: self.labels,
			SAVE_TEST_PREDICTIONS: self.predictions,
			SAVE_TEST_COSTS: self.costs,
			SAVE_TEST_OUTPUTS: self.outputs
		}

		self.file.read_data(format)
		self.file.close()

		self.labels = self.labels[0][0]
		self.predictions = self.predictions[0][0]
		self.costs = self.costs[0]
		self.outputs = self.outputs[0]

		self.colors = ['black', 'blue', 'red', 'green', 'yellow', 'orange', 'pink', 'brown', 'cyan', 'magenta']

	def _save(self, filename):
		plt.savefig(f'{self.dir}/test_{filename}.png')
		plt.close()
	
	def _title(self, title):
		plt.title(f"{title} - {self.netname}")

	def plot_costs(self):
		for item in self.costs:
			plt.plot(item)
		
		plt.ylabel("Cost")
		plt.xlabel("Testing sample")
		
		self._title("Final cost in testing")
		self._save("costs")
	
	def plot_preds(self):
		false = self.num_samples - self.num_correct

		fig, (pie_axis, tbl_axis) = plt.subplots(1, 2, figsize=(10,5))
		pie_axis.pie([self.num_correct, false], labels=[f"correct: {self.num_correct}", f"false: {false}"])

		table = [
			["total", self.num_samples],
			["accuracy", self.num_correct / self.num_samples],
			["",""]
		]

		tbl_axis.axis("off")
		tbl_axis.table(table, loc="center")

		self._title("Prediction stats")
		self._save("preds")
	
	def plot_outputs(self):
		for i in range(self.num_samples):
			target_i = self.targets.index(self.labels[i])
			plt.scatter(range(self.ntargets), self.outputs[i], c=self.colors[target_i % self.ntargets])
		
		plt.legend([f"{self.targets[i]}" for i in range(self.ntargets)])
		plt.ylabel("Neuron value")
		plt.xlabel("Neuron")
		
		self._title("Output vectors")
		self._save("outputs")


	def plot_all(self):
		self.plot_costs()
		self.plot_preds()
		self.plot_outputs()

if __name__ == '__main__':
	parser = argparse.ArgumentParser()
	parser.add_argument('-f', '--folder')
	args = parser.parse_args()

	if not args.folder:
		folders = os.listdir('results')
		paths = [os.path.join('results', basename) for basename in folders]
		args.folder = f'{max(paths, key=os.path.getctime)}'
	
	network = f"{args.folder}/{[x for x in os.listdir(args.folder) if '.' not in x][0]}"

	train = TrainData(f'{network}.traindata')
	train.plot_all()

	test = TestData(f"{network}.testdata")
	test.plot_all()
